{"version":3,"sources":["../src/symbols.ts","../src/decorators/content.decorators.ts","../src/factories/plugin.ts","../src/factories/charactor.ts","../src/di.ts","../src/templates.ts","../src/actions/baseInjectableAction.ts","../src/evaluators/baseInjectableEvaluator.ts"],"sourcesContent":["/**\n * Factory Symbols used in the library\n */\nexport const FACTORIES = {\n    PluginFactory: Symbol.for(\"PluginFactory\"),\n};\n","import \"reflect-metadata\";\nimport { z } from \"zod\";\nimport type { ContentPropertyDescription } from \"../types\";\n\nconst CONTENT_METADATA_KEY = \"content:properties\";\n\nexport type ContentClass<T> = {\n    new (...args: unknown[]): T;\n    prototype: T;\n};\n\ninterface ContentPropertyConfig extends ContentPropertyDescription {\n    schema: z.ZodType;\n}\n\nexport function property(config: ContentPropertyConfig) {\n    return (target: object, propertyKey: string) => {\n        const properties =\n            Reflect.getMetadata(CONTENT_METADATA_KEY, target) || {};\n        properties[propertyKey] = config;\n        Reflect.defineMetadata(CONTENT_METADATA_KEY, properties, target);\n    };\n}\n\n/**\n * Create a Zod schema from a class decorated with @property\n *\n * @param cls\n * @returns\n */\nexport function createZodSchema<T>(cls: ContentClass<T>): z.ZodType<T> {\n    const properties: Record<string, ContentPropertyConfig> =\n        Reflect.getMetadata(CONTENT_METADATA_KEY, cls.prototype) || {};\n    const schemaProperties = Object.entries(properties).reduce(\n        (acc, [key, { schema }]) => {\n            acc[key] = schema;\n            return acc;\n        },\n        {} as Record<string, z.ZodType<T>>\n    );\n    return z.object(schemaProperties) as unknown as z.ZodType<T>;\n}\n\n/**\n * Load the description of each property from a class decorated with @property\n *\n * @param cls\n * @returns\n */\nexport function loadPropertyDescriptions<T>(\n    cls: ContentClass<T>\n): Record<string, ContentPropertyDescription> {\n    const properties: Record<string, ContentPropertyConfig> =\n        Reflect.getMetadata(CONTENT_METADATA_KEY, cls.prototype) || {};\n    return Object.entries(properties).reduce(\n        (acc, [key, { description, examples }]) => {\n            acc[key] = { description, examples };\n            return acc;\n        },\n        {} as Record<string, ContentPropertyDescription>\n    );\n}\n","import type { interfaces } from \"inversify\";\nimport {\n    elizaLogger,\n    type Plugin,\n} from \"@elizaos/core\";\nimport type { PluginFactory, PluginOptions } from \"../types\";\n\n/**\n * Get an instance from the container\n * @param ctx\n * @param item\n * @param type\n * @returns\n */\nasync function getInstanceFromContainer<T>(\n    ctx: interfaces.Context,\n    item: T | (new (...args: any[]) => T),\n    type: string\n): Promise<T | undefined> {\n    if (typeof item === \"function\") {\n        try {\n            return await ctx.container.getAsync(item);\n        } catch (e) {\n            elizaLogger.error(\n                `Error normalizing ${type}: ${(item as Function).name}`,\n                e.message\n            );\n            return undefined;\n        }\n    }\n    return item;\n}\n\n/**\n * Create a plugin factory\n */\nexport function createPlugin(ctx: interfaces.Context): PluginFactory {\n    return async (opts: PluginOptions): Promise<Plugin> => {\n        // Create a new plugin object\n        const plugin: Plugin = {\n            name: opts.name,\n            description: opts.description,\n        };\n\n        // Handle providers - if provided, map through them\n        // For class constructors (functions), get instance from container\n        // For regular providers, use as-is\n        if (typeof opts.providers !== \"undefined\") {\n            plugin.providers = (\n                await Promise.all(\n                    opts.providers.map((provider) =>\n                        getInstanceFromContainer(\n                            ctx,\n                            provider,\n                            \"provider\"\n                        )\n                    )\n                )\n            ).filter(Boolean); // Filter out undefined providers\n        }\n\n        // Handle actions - if provided, map through them\n        // For class constructors (functions), get instance from container\n        // For regular actions, use as-is\n        if (typeof opts.actions !== \"undefined\") {\n            plugin.actions = (\n                await Promise.all(\n                    opts.actions.map((action) =>\n                        getInstanceFromContainer(ctx, action, \"action\")\n                    )\n                )\n            ).filter(Boolean); // Filter out undefined actions\n        }\n\n        // Handle evaluators - if provided, map through them\n        // For class constructors (functions), get instance from container\n        // For regular evaluators, use as-is\n        if (typeof opts.evaluators !== \"undefined\") {\n            plugin.evaluators = (\n                await Promise.all(\n                    opts.evaluators.map((evaluator) =>\n                        getInstanceFromContainer(\n                            ctx,\n                            evaluator,\n                            \"evaluator\"\n                        )\n                    )\n                )\n            ).filter(Boolean); // Filter out undefined evaluators\n        }\n\n        // Handle services - if provided, assign directly\n        if (typeof opts.services !== \"undefined\") {\n            plugin.services = (\n                await Promise.all(\n                    opts.services.map((service) =>\n                        getInstanceFromContainer(ctx, service, \"service\")\n                    )\n                )\n            )\n        }\n\n        // Handle clients - if provided, assign directly\n        if (typeof opts.clients !== \"undefined\") {\n            plugin.clients = (\n                await Promise.all(\n                    opts.clients.map((client) =>\n                        getInstanceFromContainer(ctx, client, \"client\")\n                    )\n                )\n            )\n        }\n        return plugin;\n    };\n}\n","import { type Character, elizaLogger, type Plugin } from \"@elizaos/core\";\nimport { globalContainer } from \"../di\";\nimport type { PluginFactory } from \"../types\";\nimport { FACTORIES } from \"../symbols\";\n\n/**\n * Normalize a character by creating all plugins from the character's plugin list using the PluginFactory\n * @param character\n */\nexport async function normalizeCharacter(\n    character: Character\n): Promise<Character> {\n    // Use the PluginFactory to import the plugins within the same request for each character\n    const createPlugin = globalContainer.get<PluginFactory>(\n        FACTORIES.PluginFactory\n    );\n\n    const normalizePlugin = async (plugin: any) => {\n        if (\n            typeof plugin?.name === \"string\" &&\n            typeof plugin?.description === \"string\"\n        ) {\n            try {\n                const normalized = await createPlugin(plugin);\n                elizaLogger.info(\"Normalized plugin:\", normalized.name);\n                return normalized;\n            } catch (e) {\n                elizaLogger.error(\n                    `Error normalizing plugin: ${plugin.name}`,\n                    e.message\n                );\n            }\n        }\n        return plugin;\n    };\n\n    let plugins: Plugin[] = [];\n    if (character.plugins?.length > 0) {\n        const normalizedPlugins = await Promise.all(\n            character.plugins.map(normalizePlugin)\n        );\n        const validPlugins = normalizedPlugins.filter(\n            (plugin): plugin is Plugin => plugin !== undefined\n        );\n        if (validPlugins.length !== character.plugins.length) {\n            elizaLogger.warn(\n                `Some plugins failed to normalize: ${character.plugins.length - validPlugins.length} failed`\n            );\n        }\n        plugins = validPlugins;\n    }\n    return Object.assign({}, character, { plugins }) as Character;\n}\n","import type { Plugin } from \"@elizaos/core\";\nimport { Container, type interfaces } from \"inversify\";\nimport { FACTORIES } from \"./symbols\";\nimport { createPlugin } from \"./factories\";\nimport type { PluginOptions } from \"./types\";\n\nconst globalContainer = new Container();\n\n// ----- Bind to factory functions -----\n\nglobalContainer\n    .bind<interfaces.Factory<Promise<Plugin>>>(FACTORIES.PluginFactory)\n    .toFactory<Promise<Plugin>, [PluginOptions]>(createPlugin);\n\nexport { globalContainer };\n","import { z } from \"zod\";\nimport type { ContentPropertyDescription } from \"./types\";\n\n/**\n * build the content output template\n * @param properties The properties of the content\n * @param schema The Zod schema of the content\n */\nexport function buildContentOutputTemplate(\n    actionName: string,\n    actionDesc: string,\n    properties: Record<string, ContentPropertyDescription>,\n    schema: z.ZodType<any>\n): string {\n    let propDesc = \"\";\n    Object.entries(properties).forEach(([key, { description, examples }]) => {\n        propDesc += `- Field **\"${key}\"**: ${description}.`;\n        if (examples?.length > 0) {\n            propDesc += \" Examples or Rules for this field:\\n\";\n        } else {\n            propDesc += \"\\n\";\n        }\n        examples?.forEach((example, index) => {\n            propDesc += `    ${index + 1}. ${example}\\n`;\n        });\n    });\n    return `Perform the action: \"${actionName}\".\nAction description is \"${actionDesc}\".\n\n### TASK: Extract the following details about the requested action\n\n${propDesc}\n\nUse null for any values that cannot be determined.\n\nRespond with a JSON markdown block containing only the extracted values with this structure:\n\n\\`\\`\\`json\n${zodSchemaToJson(schema)}\n\\`\\`\\`\n\nHere are the recent user messages for context:\n{{recentMessages}}\n`;\n}\n\n/**\n * Convert a Zod schema to JSON\n * @param schema Zod schema\n * @returns JSON string\n */\nexport function zodSchemaToJson(schema: z.ZodType<any>): string {\n    if (schema instanceof z.ZodObject) {\n        const shape = schema.shape;\n        const properties = Object.entries(shape).map(([key, value]) => {\n            return `\"${key}\": ${zodTypeToJson(value as z.ZodType)}`;\n        });\n        return `{\\n${properties.join(\",\\n\")}\\n}`;\n    }\n    return \"\";\n}\n\n/**\n * Convert a Zod type to JSON\n * @param schema Zod type\n */\nfunction zodTypeToJson(schema: z.ZodType<any>): string {\n    if (schema instanceof z.ZodNullable || schema instanceof z.ZodOptional) {\n        return `${zodTypeToJson(schema._def.innerType)} | null`;\n    }\n    if (schema instanceof z.ZodUnion) {\n        return schema._def.options.map(zodTypeToJson).join(\" | \");\n    }\n    if (schema instanceof z.ZodString) {\n        return \"string\";\n    }\n    if (schema instanceof z.ZodNumber) {\n        return \"number\";\n    }\n    if (schema instanceof z.ZodBoolean) {\n        return \"boolean\";\n    }\n    if (schema instanceof z.ZodArray) {\n        return `${zodTypeToJson(schema._def.type)}[]`;\n    }\n    if (schema instanceof z.ZodObject) {\n        return zodSchemaToJson(schema);\n    }\n    return \"any\";\n}\n","import { injectable, unmanaged } from \"inversify\";\nimport type { z } from \"zod\";\nimport {\n    type ActionExample,\n    composeContext,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n} from \"@elizaos/core\";\nimport {\n    type ContentClass,\n    createZodSchema,\n    loadPropertyDescriptions,\n} from \"../decorators\";\nimport type { ActionOptions, InjectableAction } from \"../types\";\nimport { buildContentOutputTemplate } from \"../templates\";\n\n// type ActionResult = unknown;\n\n/**\n * Base abstract class for injectable actions\n */\n@injectable()\nexport abstract class BaseInjectableAction<T> implements InjectableAction<T> {\n    // -------- Properties --------\n    public name: string;\n    public similes: string[];\n    public description: string;\n    public examples: ActionExample[][];\n    public suppressInitialMessage: boolean;\n\n    /**\n     * The content class for the action\n     */\n    protected readonly contentClass: ContentClass<T>;\n    /**\n     * Optional template for the action, if not provided, it will be generated from the content class\n     */\n    protected readonly template: string;\n    /**\n     * Optional content schema for the action, if not provided, it will be generated from the content class\n     */\n    protected readonly contentSchema: z.ZodSchema<T>;\n\n    /**\n     * Constructor for the base injectable action\n     */\n    constructor(@unmanaged() opts: ActionOptions<T>) {\n        // Set the action properties\n        this.name = opts.name;\n        this.similes = opts.similes;\n        this.description = opts.description;\n        this.examples = opts.examples;\n        this.suppressInitialMessage = opts.suppressInitialMessage ?? false; // Default to false\n        // Set the content class, template and content schema\n        this.contentClass = opts.contentClass;\n        this.template = opts.template;\n        this.contentSchema = opts.contentSchema;\n\n        if (this.contentClass !== undefined) {\n            if (this.contentSchema === undefined) {\n                this.contentSchema = createZodSchema(this.contentClass);\n            }\n            if (this.template === undefined) {\n                const properties = loadPropertyDescriptions(this.contentClass);\n                this.template = buildContentOutputTemplate(\n                    this.name,\n                    this.description,\n                    properties,\n                    this.contentSchema\n                );\n            }\n        }\n    }\n\n    // -------- Abstract methods to be implemented by the child class --------\n\n    /**\n     * Abstract method to execute the action\n     * @param content The content object\n     * @param callback The callback function to pass the result to Eliza runtime\n     */\n    abstract execute(\n        content: T | null,\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        callback?: HandlerCallback\n    ): Promise<unknown | null>;\n\n    // -------- Implemented methods for Eliza runtime --------\n\n    /**\n     * Default implementation of the validate method\n     * You can override this method to add custom validation logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @returns The validation result\n     */\n    async validate(\n        _runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State\n    ): Promise<boolean> {\n        // Default implementation is to return true\n        return true;\n    }\n\n    /**\n     * Default implementation of the preparation of action context\n     * You can override this method to add custom logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     */\n    protected async prepareActionContext(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State\n    ): Promise<string> {\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n        // Compose context\n        return composeContext({ state: currentState, template: this.template });\n    }\n\n    /**\n     * Default method for processing messages\n     * You can override this method to add custom logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @returns The generated content from AI based on the message\n     */\n    protected async processMessages(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State\n    ): Promise<T | null> {\n        const actionContext = await this.prepareActionContext(\n            runtime,\n            message,\n            state\n        );\n\n        if (!actionContext) {\n            elizaLogger.error(\"Failed to prepare action context\");\n            return null;\n        }\n\n        // Generate transfer content\n        const resourceDetails = await generateObject({\n            runtime,\n            context: actionContext,\n            modelClass: ModelClass.SMALL,\n            schema: this.contentSchema,\n        });\n\n        elizaLogger.debug(\"Response: \", resourceDetails.object);\n\n        // Validate content\n        const parsedObj = await this.contentSchema.safeParseAsync(\n            resourceDetails.object\n        );\n        if (!parsedObj.success) {\n            elizaLogger.error(\n                \"Failed to parse content: \",\n                JSON.stringify(parsedObj.error?.flatten())\n            );\n            return null;\n        }\n        return parsedObj.data;\n    }\n\n    /**\n     * Default Handler function type for processing messages\n     * You can override this method to add custom logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @param options The options object from Eliza framework\n     * @param callback The callback function to pass the result to Eliza runtime\n     */\n    async handler(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        _options?: Record<string, unknown>,\n        callback?: HandlerCallback\n    ): Promise<unknown | null> {\n        let content: T;\n        try {\n            content = await this.processMessages(runtime, message, state);\n        } catch (err) {\n            elizaLogger.error(\"Error in processing messages:\", err.message);\n\n            if (callback) {\n                await callback?.({\n                    text: `Unable to process transfer request. Invalid content: ${err.message}`,\n                    content: {\n                        error: \"Invalid content\",\n                    },\n                });\n            }\n            return null;\n        }\n\n        try {\n            return await this.execute(\n                content,\n                runtime,\n                message,\n                state,\n                callback\n            );\n        } catch (err) {\n            elizaLogger.error(\"Error in executing action:\", err.message);\n        }\n    }\n}\n","import { injectable, unmanaged } from \"inversify\";\nimport type {\n    IAgentRuntime,\n    EvaluationExample,\n    Memory,\n    State,\n    HandlerCallback,\n} from \"@elizaos/core\";\nimport type { EvaluatorOptions, InjectableEvaluator } from \"../types\";\n\n/**\n * Base abstract class for injectable actions\n */\n@injectable()\nexport abstract class BaseInjectableEvaluator implements InjectableEvaluator {\n    // -------- Properties --------\n    public alwaysRun: boolean;\n    public name: string;\n    public similes: string[];\n    public description: string;\n    public examples: EvaluationExample[];\n\n    /**\n     * Constructor for the base injectable action\n     */\n    constructor(@unmanaged() opts: EvaluatorOptions) {\n        // Set the action properties\n        this.name = opts.name;\n        this.similes = opts.similes;\n        this.description = opts.description;\n        this.examples = opts.examples;\n        this.alwaysRun = opts.alwaysRun ?? false; // Default to false\n    }\n\n    /**\n     * Default implementation of the validate method\n     * You can override this method to add custom validation logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @returns The validation result\n     */\n    async validate(\n        _runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State\n    ): Promise<boolean> {\n        // Default implementation is to return true\n        return true;\n    }\n\n    /**\n     * Handler for the evaluator\n     */\n    abstract handler(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        options?: Record<string, unknown>,\n        callback?: HandlerCallback\n    ): Promise<unknown>;\n}\n"],"mappings":"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","names":["FACTORIES","PluginFactory","Symbol","for","z","CONTENT_METADATA_KEY","property","config","target","propertyKey","properties","Reflect","getMetadata","defineMetadata","createZodSchema","cls","prototype","schemaProperties","Object","entries","reduce","acc","key","schema","z","object","loadPropertyDescriptions","description","examples","elizaLogger","getInstanceFromContainer","ctx","item","type","container","getAsync","e","elizaLogger","error","name","message","undefined","createPlugin","opts","plugin","description","providers","Promise","all","map","provider","filter","Boolean","actions","action","evaluators","evaluator","services","service","clients","client","elizaLogger","Container","globalContainer","Container","bind","FACTORIES","PluginFactory","toFactory","createPlugin","normalizeCharacter","character","createPlugin","globalContainer","get","FACTORIES","PluginFactory","normalizePlugin","plugin","name","description","normalized","elizaLogger","info","e","error","message","plugins","length","normalizedPlugins","Promise","all","map","validPlugins","filter","undefined","warn","Object","assign","z","buildContentOutputTemplate","actionName","actionDesc","properties","schema","propDesc","Object","entries","forEach","key","description","examples","length","example","index","zodSchemaToJson","z","ZodObject","shape","map","value","zodTypeToJson","join","ZodNullable","ZodOptional","_def","innerType","ZodUnion","options","ZodString","ZodNumber","ZodBoolean","ZodArray","type","injectable","unmanaged","composeContext","elizaLogger","generateObject","ModelClass","BaseInjectableAction","name","similes","description","examples","suppressInitialMessage","contentClass","template","contentSchema","constructor","opts","undefined","createZodSchema","properties","loadPropertyDescriptions","buildContentOutputTemplate","validate","_runtime","_message","_state","prepareActionContext","runtime","message","state","currentState","composeState","updateRecentMessageState","composeContext","processMessages","actionContext","elizaLogger","error","resourceDetails","generateObject","context","modelClass","ModelClass","SMALL","schema","debug","object","parsedObj","safeParseAsync","success","JSON","stringify","flatten","data","handler","_options","callback","content","err","text","execute","injectable","unmanaged","BaseInjectableEvaluator","alwaysRun","name","similes","description","examples","constructor","opts","validate","_runtime","_message","_state"]}